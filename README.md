# lru-cache

### Run
```
1
-1
-1
3
4

Process finished with exit code 0
```

### Tests
```
=== RUN   TestNewLRU
--- PASS: TestNewLRU (0.00s)
=== RUN   TestLRU
--- PASS: TestLRU (0.00s)
=== RUN   TestLRU_StorageBug
--- PASS: TestLRU_StorageBug (0.00s)
=== RUN   TestLRU_ConcurrentWrite
--- PASS: TestLRU_ConcurrentWrite (0.00s)
PASS
ok      lru-cache/cache 0.010s

Process finished with exit code 0
```

### Описание
Для реализации "вытеснения" элементов кэша был выбран обычный двусвязный список **container.list**:
* быстрая вставка элементов в начало списка
* быстрое удаление элементов в конце списка

Обе операции легковесные, поскольку нужно только обновить ссылки на предыдущий и последующий элемент в узлах, над которыми производятся манипуляции.

После того, как элемент помещен в список, ссылку на элемент списка помещаем в HashMap, который в наилучшем случае обеспечит O(1) на операции чтения/вставки.
В худшем случае, сложность этих операций будет O(n), поскольку в случае возникновения коллизий, придется использовать какой-либо алгоритм для их разрешения (зависит от конкретной реализации хэш-таблиц в языке).

Нарпимер, в случае с "методом цепочек", придется осуществлять перебор проблемных ключей и использовать полное сравнение.